# Task description


# Solution description
## Требования
1. Каждый комментарий имеет привязку к определенному пользователю.
2. У каждого комментария есть дата создания.
3. Коментарии имеют древовидную структуру - есть возможность оставлять
комментарии на комментарии с неограниченной степенью вложенности.
4. Каждой комментарий имеет привязку к определенной сущности (пост в блоге,
страница пользователя, другой комментарий и т.п.), которая однозначно
идентифицируется парой значений (идентификатор типа сущности,
идентификатор сущности).
5. Бэкенд должен предоставлять следующие интерфейсы:
    1. Создание комментария к определенной сущности с указанием
сущности, к которой он относится.
    2. Получение комментариев первого уровня для определенной
сущности с пагинацией.
    3. Получение всех дочерних комментариев для заданного
комментария или сущности без ограничения по уровню
вложенности. Корнем может являться пара идентифицирующая
сущность или id комментария, являющегося корневым для данной
ветки. Ответ должен быть таким, чтобы на клиенте можно было
воссоздать иерархию комментариев.
    4. Получение истории комментариев определенного пользователя.
    5. Выгрузка в файл (например в xml-формате) всей истории
комментариев по пользователю или сущности с возможностью
указания интервала времени, в котором был создан комментарий
пользователя (если не задан - выводить всё). Время ответа на
первичный запрос не должно зависеть от объема данных в
итоговой выгрузке.
6. Время ответа на все запросы ограничено 1 секундной. С условием:
    1. глубина дерева не менее 100,
    2. количество узлов (элементов, имеющих дочерние элементы) в дереве
не менее 10^4.

## Дополнительные требования
1. Комментарии могут редактироваться и удаляться. Удаление возможно только,
если у комментария нет дочерних комментариев. Реализовать хранение
исторических данных с возможностью получения истории для определенного
комментария: информация о том, кем и когда был изменен/удален
комментарий, что изменилось в комментарии.
2. Возможность подписки на события комментирования определенной сущности -
при создании/редактировании/удалении комментария к этой сущности с
сервера уходит PUSH-уведомление клиенту с информацией о
созданном/отредактированным/удаленным комментарием в таком виде, чтобы
клиент имел возможность динамически добавить/обновить/удалить его в
интерфейсе.
3. Для пункта 5.v требований реализовать гибкий механизм с возможностью
добавления различных форматов файлов


 ## Описание решения.
Приложение предоставляет REST API для работы с сервисом комментариев. 

Используемые технические средства: 
* python 3.6, 
* dgango rest framework, 
* Django framework

В данном решении для комментирования доступны следующие сущности:
* Страница (`Page`)
* Пост (`Post`)
* Комментарий(`Comment`)

Предложенная архитектура (композиция с `Entity`) позволяет быстро добавлять новые сущности для комментирования.
Подписка на события реальзована с использованием библиотеки `django-channels`, позволяющей отправлять `PUSH` уведовмления с сервера. 

Для выгрузки в файл всей истории комментариев используется асинхронная задача, которая обрабатыввается в `celery`. В ответ на запрос пользователь получает идентификатор задачи, после выполнения которой будет отправлено PUSH-сообщение c `url` сформированного файла. Подписка на события должна осуществляться по идентификатору задачи.
В качестве альтернативного варианта системы очередей задач можно было бы использовать библиотеку `Channels`.  Однако согласно документации `Channels` не гарантирует выполнение задачи, так как отсутствует failover/retry механизм:
_Channels’ design is such that anything is allowed to fail - a consumer can error and not send replies, the channel layer can restart and drop a few messages, a dogpile can happen and a few incoming clients get rejected._

Для добавления различных форматов файлов для пункта 5.v осудествляется посредством расширения словаря форматов `ext_serializer_dict` функции `get_history` и реализации соответствующих сериалайзеров данных. 
Возможность добавления дополнительных средств обработки сериализованных данных перед сохранением в файл, путем расширения словаря `ext_dict` задачи `save_history_to_fil` расширяет возможности обработки данных.

### Описание методов
1.
2.
3.
4.
## Запуск
